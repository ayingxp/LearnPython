# -*- coding: utf-8 -*-

u"""
一、概念说明
- 用户空间和内核空间
    现代操作系统都是采用虚拟存储器，那么对于32位操作系统，它的寻址空间（虚拟存储空间）位4G（2的32次方）。
    操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的权限。
    为了保护用户进程不能直接操作内核(kernel),保护内核的安全，操作系统将虚拟空间划分位两部分，一部分为
    内核空间，一部分位用户空间。
    针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF),供内核使用，称为内核空间。
    而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）,供各个进程使用，称为用户空间。

- 进程切换
    为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行，这种行为被称为进程切换。
    因此，可以说任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
    从一个进程的运行转换到另一个进程上运行，这个过程经过下面这些变化：
    1. 保存处理机上下文，包括程序计数器和其他寄存器
    2. 更新PCB(进程管理块)信息
        为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块（PCB Process Control Block）,它是进程实体的一部分，
        是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程
        运行的全过程，知道进程撤消而消退。
    3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
    4. 选择另一个进程执行，并更新其PCB
    5. 更新内存管理的数据结构
    6. 恢复处理机上下文

- 进程的阻塞
    正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，
    则由系统自动执行阻塞原语(block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有
    处于运行态的进程（获得CPU）,才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。

- 文件描述符
    文件描述符（file descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
    文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。
    当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写
    往往会围绕着文件描述符展开。但是文件描述符这一概念只适用于LINUX、UNIX这样的系统。

- 缓存I/O
    缓存I/O又被称为标准I/O,大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据
    缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，
    然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

    缓存I/O的缺点:
    数据在传输过程中，需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝所带来的CPU以及内存开销是非常大的。


二、IO模式
    对于一次IO访问（以read为例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
    所以说，当一个read操作发生时，它会经历两个阶段：
    1. 等待数据准备（waiting for the data to be ready）
    2. 将数据从内核拷贝到进程中（Copying the data from the kernel to the process）

    基于以上两个阶段，linux系统产生了下面5种网络模式的方案:
    - 阻塞I/O(blocking IO)
        linux中，在默认情况下所有的socket都是blocking（阻塞的）。
        blocking I/O的特点是，在IO执行的两个阶段(等待数据以及拷贝数据)都被block了。

    - 非阻塞I/O(nonblocking IO)
        在linux中，可以通过设置socket使其变成non-blocking状态.
        当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会阻塞用户进程，二是立刻返回一个error。
        从用户进程的角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，
        它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就讲数据
        拷贝到了用户内存，然后返回。

        所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。

    - I/O 多路复用(IO multiplexing)
    - 信号驱动I/O（signal driven IO）
    - 异步I/O(asynchronous IO)

"""
